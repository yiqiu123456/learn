##  什么是执行上下文？
  简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。
  每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。

##  执行上下文的类型
  JavaScript 中有三种执行上下文类型。
  全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
  函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
  Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

##  怎么创建执行上下文？
  在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：
  1.this 值的决定，即我们所熟知的 This 绑定。
  2.创建词法环境组件。
  3.创建变量环境组件。

## 执行上下文增强
  虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时
    
    try/catch 语句的 catch 块
    with 语句
    这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明
    function buildUrl() {
        let qs = "?debug=true";
        with(location){       // with 语句将 location 对象作为上下文
            let url = href + qs; // 当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性
        }
        return url;
    } 

## 作用域
  作用域是指程序源代码中定义变量的区域。
  作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
  JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。
  因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

  如果要判断一个函数的this绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断this的绑定对象：
  由new调用：绑定到新创建的对象
  由call或apply、bind调用：绑定到指定的对象
  由上下文对象调用：绑定到上下文对象
  默认：全局对象